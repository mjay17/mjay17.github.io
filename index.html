<!DOCTYPE html>
<html>
<head>
	<title>Where to relocate in USA?</title>
	<meta name="author" content="Mritunjay Tripathi" />
	<meta name="description" content="Evaluate large US metropolitan areas to relocate." />
	<script src="https://d3js.org/d3.v4.min.js" charset="utf-8"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-annotation/2.3.0/d3-annotation.min.js"></script>
	<script type="text/javascript" src="fullPage/fullpage.js"></script>
	<link rel="stylesheet" type="text/css" href="fullPage/fullpage.css" />
	
	<style>
		.grid line {
		  stroke: lightgrey;
		  stroke-opacity: 0.7;
		  shape-rendering: crispEdges;
		}

		.grid path {
		  stroke-width: 0;
		}

		.line {
		  fill: none;
		  stroke: steelblue;
		  stroke-width: 1.5px;
		}

		#index{
			position:absolute;
			top:100px;
			right:75px;
		}
		
		.left-bottom {
			position: absolute;
			top: 80%;
			left: 110px;
			color: black;
			text-align: left;
			background-color: #ededed;
			padding: 6px 6px 6px 6px;
		}
		
		.about-this {
			position: absolute;
			left: 10px;
			bottom: 10px;
			text-align: left;
			font: bold 14px Arial;
			text-decoration: none;
			background-color: lightgrey;
			color: #333333;
			padding: 6px 6px 6px 6px;
		}
		
		.left-div {
			float: left;
			width: 20%;
			overflow: hidden;
			color: black;
			text-align: left;
			margin-left: 75px;
			vertical-align: middle;
			margin-top: 50px;
		} 
		
		.right-div {
			overflow: hidden;
			color: black;
		}
		
		.about {
			margin-left: 250px; 
			margin-right: 250px;
		}
		
		.legend {
			padding: 5px;
			font: 10px sans-serif;
			background: yellow;
			box-shadow: 2px 2px 1px #888;
		}

	</style>
</head>

<body>
	<div id="fullpage">
		<div class="section" id="section-1">
			<div>
				<div style="display: flex; justify-content: center;">
					<img src="./img/Indecisiveness.jpg" alt="US Metropolitan areas">
				</div>
				<p class="left-bottom">
					<font size="6">Where to relocate in USA?</font><br>
					<font size="4">Where next? Evaluate large US metropolitan areas to relocate.</font><br><br><br><br>
					<a class="about-this" href="#glossaryPage">About this Visualization</a>
				</p>
			</div>
		</div>
		<div class="section" id="section-2">
			<div class="slide" data-anchor="slide1">
				<div>
					<div class="left-div">
						<br><br><br><br><br><br>
						<p><font size="6">Cost of Living Indexes</font></p>
						<font size="4">First let's see how is the cost of living in the selected large US metropolitan areas.<br><br></font>
					</div>    
					<div class="right-div">
						<svg id = "svg1" width = "960" height = "500"></svg>
						<script type="text/javascript">
	
							var svg = d3.select("#svg1"),
								margin = {top: 20, right: 100, bottom: 40, left: 60},
								width = svg.attr("width") - margin.left - margin.right,
								height = svg.attr("height") - margin.top - margin.bottom,
							g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
							g.append('text').html('Cost of Living Index for large US metropolitan areas').attr('x', 275);

							var x = d3.scaleTime().range([0, width]),
								y = d3.scaleLinear().range([height, 0]),
								z = d3.scaleOrdinal(d3.schemeCategory20);
							
							var parseTime = d3.timeParse("%Y%m%d");
							
							// gridlines in x axis function
							function make_x_gridlines() {		
								return d3.axisBottom(x)
									.ticks(5)
							}

							// gridlines in y axis function
							function make_y_gridlines() {		
								return d3.axisLeft(y)
									.ticks(5)
							}
							
							var line = d3.line()
								.curve(d3.curveBasis)
								.x(function(d) { return x(d.Year); })
								.y(function(d, s) { return y(d.Cost_of_Living_Index); });
							
							const anot_type = d3.annotationCalloutCircle;
			
							const annotations = [{
							  note: {
								label: "Longer text to show text wrapping",
								title: "Annotations :)"
							  },
							  //can use x, y directly instead of data
							  data: { Year: 2016, Cost_of_Living_Index: 100 },
							  dy: 50,
							  dx: 40,
							  subject: {
								radius: 20,
								radiusPadding: 5
							  }
							}]
			
							const make_annotations = d3.annotation()
							  .editMode(false)
							  //also can set and override in the note.padding property
							  //of the annotation object
							  .notePadding(10)
							  .type(anot_type)
							  //accessors & accessorsInverse not needed
							  //if using x, y in annotations JSON
							  .accessors({
								x: d => x(d.Year),
								y: d => y(d.Cost_of_Living_Index)
							  })
							  .accessorsInverse({
								 Year: d => x.invert(d.x),
								 Cost_of_Living_Index: d => y.invert(d.y)
							  })
							  .annotations(annotations)
		
							d3.tsv("/data/DS-Data.txt", type, function(error, data) {
								if (error) throw error;

								var cities = d3.nest()
									.key(function(d) { return d.City; })
									.entries(data);
								
							x.domain([
								d3.min(cities, function(c) { return d3.min(c.values, function(d) { return d.Year; }); }),
								d3.max(cities, function(c) { return d3.max(c.values, function(d) { return d.Year; }); })
							  ]);

							y.domain([
								d3.min(cities, function(c) { return d3.min(c.values, function(d) { return d.Cost_of_Living_Index; }); }),
								d3.max(cities, function(c) { return d3.max(c.values, function(d) { return d.Cost_of_Living_Index; }); })
							  ]);

							z.domain(cities.map(function(c) { return c.key; }));

							g.append("g")
							  .attr("class", "annotation-group")
							  .call(make_annotations)

							// add the X gridlines
							g.append("g")			
								  .attr("class", "grid")
								  .attr("transform", "translate(0," + height + ")")
								  .call(make_x_gridlines()
									  .tickSize(-height)
									  .tickFormat("")
								  )

							// add the Y gridlines
							g.append("g")			
								  .attr("class", "grid")
								  .call(make_y_gridlines()
									  .tickSize(-width)
									  .tickFormat("")
								  )

							g.append("g")
								  .append("text") 
								  .attr("transform", "translate(" + (width / 2) + " ," +	(height + margin.top + 20) + ")")
								  .style("text-anchor", "middle")
								  .text("Year"); 

							g.append("g")
								  .attr("class", "axis axis--x")
								  .attr("transform", "translate(0," + height + ")")
								  .call(d3.axisBottom(x).tickFormat(d3.format('.4'))); 

							g.append("g")
								  .attr("class", "axis axis--y")
								  .call(d3.axisLeft(y))
								  .append("text")
								  .attr("transform", "rotate(-90)")
								  .attr("y", -45)
								  .attr("dy", "0.71em")
								  .attr("fill", "#000")
								  .text("Cost of Living Index");
							
							// add legend   
							var legend = g.append("g")
							  .attr("class", "legend")
							  .attr("height", 100)
							  .attr("width", 100)
							  .attr('transform', 'translate(-20,50)');    
	  
							legend.selectAll('rect')
							  .data(cities)
							  .enter()
							  .append("rect")
							  .attr("x", width + 37)
							  .attr("y", function(d, i){ return i *  20;})
							  .attr("width", 10)
							  .attr("height", 10)
							  .style("fill", function(d) { 
								return z(d.key);
							  });
	  
							legend.selectAll('text')
							  .data(cities)
							  .enter()
							  .append("text")
							  .attr("x", width + 50)
							  .attr("y", function(d, i){ return i *  20 + 9;})
							  .text(function(d) {
								return d.key;
							  });
							
							var city = g.selectAll(".city")
								.data(cities)
								.enter().append("g")
								  .attr("class", "city");

							city.append("path")
								  .attr("class", "line")
								  .attr("d", function(d) { return line(d.values); })
								  .style("stroke", function(d) { return z(d.key); });

							city.append("text")
								  .datum(function(d) { return {City: d.key, value: d.values[d.values.length - 1]}; })
								  .attr("transform", function(d) { return "translate(" + x(d.value.Year) + "," + y(d.value.Cost_of_Living_Index) + ")"; })
								  .attr("x", 3)
								  .attr("dy", "0.35em")
								  .style("font", "10px sans-serif");
								  //.text(function(d) { return d.City; });
								
							/*d3.select('#index')
								.on("change", function () {
								var sect = document.getElementById("index");
								var section = sect.options[sect.selectedIndex].value;
								
								make_plot(plot_data, section);
							});*/
							
							});	
		
							function type(d, _, columns) {
							  d.Year = +d.Year;
							  d.Cost_of_Living_Index = +d.Cost_of_Living_Index;
							  d.Cost_of_Living_Plus_Rent_Index = +d.Cost_of_Living_Plus_Rent_Index;
							  d.Groceries_Index = +d.Groceries_Index;
							  d.Local_Purchasing_Power_Index = +d.Local_Purchasing_Power_Index;
							  d.Rent_Index = +d.Rent_Index;
							  d.Restaurant_Price_Index = +d.Restaurant_Price_Index;
							  d.Unemployment_Rate = +d.Unemployment_Rate;
		  
							  return d;
							}
							
						</script>
					</div> 
				</div>
			</div>
			<div class="slide" data-anchor="slide2">
				<div>
					<div class="left-div">
						<br><br><br><br><br><br>
						<p><font size="6">Unemployment Rate</font></p>
						<font size="4">Now let's see how is the unemployment rate in the selected large US metropolitan areas.<br><br></font>
					</div>    
					<div class="right-div">
						<svg id = "svg2" width = "960" height = "500"></svg>
						<script type="text/javascript">
	
							var svg2 = d3.select("#svg2"),
								margin = {top: 20, right: 100, bottom: 40, left: 60},
								width = svg.attr("width") - margin.left - margin.right,
								height = svg.attr("height") - margin.top - margin.bottom,
							g2 = svg2.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
							g2.append('text').html('Unemployment Rate for large US metropolitan areas').attr('x', 275);

							var x = d3.scaleTime().range([0, width]),
								y = d3.scaleLinear().range([height, 0]),
								z = d3.scaleOrdinal(d3.schemeCategory20);
							
							var parseTime = d3.timeParse("%Y%m%d");
							
							// gridlines in x axis function
							function make_x_gridlines() {		
								return d3.axisBottom(x)
									.ticks(5)
							}

							// gridlines in y axis function
							function make_y_gridlines() {		
								return d3.axisLeft(y)
									.ticks(5)
							}
							
							var line2 = d3.line()
								.curve(d3.curveBasis)
								.x(function(d) { return x(d.Year); })
								.y(function(d, s) { return y(d.Unemployment_Rate); });
							
			
							const annotations2 = [{
							  note: {
								label: "Longer text",
								title: "Annotations"
							  },
							  //can use x, y directly instead of data
							  data: { Year: 2015, Unemployment_Rate: 5.7 },
							  dy: 50,
							  dx: 40,
							  subject: {
								radius: 20,
								radiusPadding: 5
							  }
							}]
			
							const make_annotations2 = d3.annotation()
							  .editMode(false)
							  //also can set and override in the note.padding property
							  //of the annotation object
							  .notePadding(10)
							  .type(anot_type)
							  //accessors & accessorsInverse not needed
							  //if using x, y in annotations JSON
							  .accessors({
								x: d => x(d.Year),
								y: d => y(d.Unemployment_Rate)
							  })
							  .accessorsInverse({
								 Year: d => x.invert(d.x),
								 Unemployment_Rate: d => y.invert(d.y)
							  })
							  .annotations(annotations2)
		
							d3.tsv("/data/DS-Data.txt", type, function(error, data) {
								if (error) throw error;

								var cities2 = d3.nest()
									.key(function(d) { return d.City; })
									.entries(data);
								
							x.domain([
								d3.min(cities2, function(c) { return d3.min(c.values, function(d) { return d.Year; }); }),
								d3.max(cities2, function(c) { return d3.max(c.values, function(d) { return d.Year; }); })
							  ]);

							y.domain([
								d3.min(cities2, function(c) { return d3.min(c.values, function(d) { return d.Unemployment_Rate; }); }),
								d3.max(cities2, function(c) { return d3.max(c.values, function(d) { return d.Unemployment_Rate; }); })
							  ]);

							z.domain(cities2.map(function(c) { return c.key; }));

							g2.append("g")
							  .attr("class", "annotation-group")
							  .call(make_annotations2)

							// add the X gridlines
							g2.append("g")			
								  .attr("class", "grid")
								  .attr("transform", "translate(0," + height + ")")
								  .call(make_x_gridlines()
									  .tickSize(-height)
									  .tickFormat("")
								  )

							// add the Y gridlines
							g2.append("g")			
								  .attr("class", "grid")
								  .call(make_y_gridlines()
									  .tickSize(-width)
									  .tickFormat("")
								  )

							g2.append("g")
								  .append("text") 
								  .attr("transform", "translate(" + (width / 2) + " ," +	(height + margin.top + 20) + ")")
								  .style("text-anchor", "middle")
								  .text("Year"); 

							g2.append("g")
								  .attr("class", "axis axis--x")
								  .attr("transform", "translate(0," + height + ")")
								  .call(d3.axisBottom(x).tickFormat(d3.format('.4'))); 

							g2.append("g")
								  .attr("class", "axis axis--y")
								  .call(d3.axisLeft(y))
								  .append("text")
								  .attr("transform", "rotate(-90)")
								  .attr("y", -45)
								  .attr("dy", "0.71em")
								  .attr("fill", "#000")
								  .text("Unemployment Rate");

							var city2 = g2.selectAll(".city")
								.data(cities2)
								.enter().append("g")
								.attr("class", "city");

							city2.append("path")
								  .attr("class", "line")
								  .attr("d", function(d) { return line2(d.values); })
								  .style("stroke", function(d) { return z(d.key); });

							city2.append("text")
								  .datum(function(d) { return {City: d.key, value: d.values[d.values.length - 1]}; })
								  .attr("transform", function(d) { return "translate(" + x(d.value.Year) + "," + y(d.value.Unemployment_Rate) + ")"; })
								  .attr("x", 3)
								  .attr("dy", "0.35em")
								  .style("font", "10px sans-serif")
								  .text(function(d) { return d.City; });
								
							/*d3.select('#index')
								.on("change", function () {
								var sect = document.getElementById("index");
								var section = sect.options[sect.selectedIndex].value;
								
								make_plot(plot_data, section);
							});*/
							
							});	
		
							function type(d, _, columns) {
							  d.Year = +d.Year;
							  d.Cost_of_Living_Index = +d.Cost_of_Living_Index;
							  d.Cost_of_Living_Plus_Rent_Index = +d.Cost_of_Living_Plus_Rent_Index;
							  d.Groceries_Index = +d.Groceries_Index;
							  d.Local_Purchasing_Power_Index = +d.Local_Purchasing_Power_Index;
							  d.Rent_Index = +d.Rent_Index;
							  d.Restaurant_Price_Index = +d.Restaurant_Price_Index;
							  d.Unemployment_Rate = +d.Unemployment_Rate;
		  
							  return d;
							}
							
						</script>
					</div> 
				</div>
			</div>
		</div>
		<div class="section" id="section-3">
			<div>
					<div class="left-div">
						<br><br><br><br><br><br>
						<p><font size="6">Breakdown of Cost of Living Indexes</font></p>
						<font size="4">Now let's analyze various cost of living indexes in the selected large US metropolitan areas.<br><br></font>
					</div>    
					<div class="right-div">
						<select id = "index">
							<option value="" selected disabled hidden>Choose Index Here</option>
							<option value="Groceries_Index">Groceries Index</option>
							<option value="Rent_Index">Rent Index</option>
							<option value="Restaurant_Price_Index">Restaurant Price Index</option>
							<option value="Local_Purchasing_Power_Index">Local Purchasing Power Index</option>
							<option value="Cost_of_Living_Plus_Rent_Index">Cost of Living Plus Rent Index</option>
						</select>
						<svg id = "svg3" width = "960" height = "500"></svg>
						<script type="text/javascript">
	
							d3.select('#index')
								.on("change", function () {
								var sect = document.getElementById("index");
								var section = sect.options[sect.selectedIndex].value;
								
								
								var svg3 = d3.select("#svg3");
								svg3.selectAll("*").remove();
								
								var	margin = {top: 20, right: 100, bottom: 40, left: 60},
									width = svg.attr("width") - margin.left - margin.right,
									height = svg.attr("height") - margin.top - margin.bottom,
								g3 = svg3.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
								g3.append('text').html('Various Cost of Living Indexes for large US metropolitan areas').attr('x', 275);

								var x = d3.scaleTime().range([0, width]),
									y = d3.scaleLinear().range([height, 0]),
									z = d3.scaleOrdinal(d3.schemeCategory20);
							
								var parseTime = d3.timeParse("%Y%m%d");
							
								// gridlines in x axis function
								function make_x_gridlines() {		
									return d3.axisBottom(x)
										.ticks(5)
								}

								// gridlines in y axis function
								function make_y_gridlines() {		
									return d3.axisLeft(y)
										.ticks(5)
								}
							
								var line3 = d3.line()
									.curve(d3.curveBasis)
									.x(function(d) { return x(d.Year); })
									.y(function(d, s) { 
										if(section == "Groceries_Index") {
											return y(d.Groceries_Index); 
										}
										else if(section == "Rent_Index") {
											return y(d.Rent_Index); 
										}
										else if(section == "Restaurant_Price_Index") {
											return y(d.Restaurant_Price_Index); 
										}
										else if(section == "Local_Purchasing_Power_Index") {
											return y(d.Local_Purchasing_Power_Index); 
										}
										else if(section == "Cost_of_Living_Plus_Rent_Index") {
											return y(d.Cost_of_Living_Plus_Rent_Index); 
										}
									});
							
								/*
								const annotations2 = [{
								  note: {
									label: "Longer text",
									title: "Annotations"
								  },
								  //can use x, y directly instead of data
								  data: { Year: 2015, Unemployment_Rate: 5.7 },
								  dy: 50,
								  dx: 40,
								  subject: {
									radius: 20,
									radiusPadding: 5
								  }
								}]
			
								const make_annotations2 = d3.annotation()
								  .editMode(false)
								  //also can set and override in the note.padding property
								  //of the annotation object
								  .notePadding(10)
								  .type(anot_type)
								  //accessors & accessorsInverse not needed
								  //if using x, y in annotations JSON
								  .accessors({
									x: d => x(d.Year),
									y: d => y(d.Unemployment_Rate)
								  })
								  .accessorsInverse({
									 Year: d => x.invert(d.x),
									 Unemployment_Rate: d => y.invert(d.y)
								  })
								  .annotations(annotations2)
								  */
		
								d3.tsv("/data/DS-Data.txt", type, function(error, data) {
									if (error) throw error;

									var cities3 = d3.nest()
										.key(function(d) { return d.City; })
										.entries(data);
								
								x.domain([
									d3.min(cities3, function(c) { return d3.min(c.values, function(d) { return d.Year; }); }),
									d3.max(cities3, function(c) { return d3.max(c.values, function(d) { return d.Year; }); })
								  ]);
								
								if(section == "Groceries_Index") {
									y.domain([
									d3.min(cities3, function(c) { return d3.min(c.values, function(d) { return d.Groceries_Index; }); }),
									d3.max(cities3, function(c) { return d3.max(c.values, function(d) { return d.Groceries_Index; }); })
								  ]); 
								}
								else if(section == "Rent_Index") {
									y.domain([
									d3.min(cities3, function(c) { return d3.min(c.values, function(d) { return d.Rent_Index; }); }),
									d3.max(cities3, function(c) { return d3.max(c.values, function(d) { return d.Rent_Index; }); })
								  ]); 
								}
								else if(section == "Restaurant_Price_Index") {
									y.domain([
									d3.min(cities3, function(c) { return d3.min(c.values, function(d) { return d.Restaurant_Price_Index; }); }),
									d3.max(cities3, function(c) { return d3.max(c.values, function(d) { return d.Restaurant_Price_Index; }); })
								  ]); 
								}
								else if(section == "Local_Purchasing_Power_Index") {
									y.domain([
									d3.min(cities3, function(c) { return d3.min(c.values, function(d) { return d.Local_Purchasing_Power_Index; }); }),
									d3.max(cities3, function(c) { return d3.max(c.values, function(d) { return d.Local_Purchasing_Power_Index; }); })
								  ]); 
								}
								else if(section == "Cost_of_Living_Plus_Rent_Index") {
									y.domain([
									d3.min(cities3, function(c) { return d3.min(c.values, function(d) { return d.Cost_of_Living_Plus_Rent_Index; }); }),
									d3.max(cities3, function(c) { return d3.max(c.values, function(d) { return d.Cost_of_Living_Plus_Rent_Index; }); })
								  ]); 
								}

								z.domain(cities3.map(function(c) { return c.key; }));

								/*
								g3.append("g")
								  .attr("class", "annotation-group")
								  .call(make_annotations2)
								*/
								
								// add the X gridlines
								g3.append("g")			
									  .attr("class", "grid")
									  .attr("transform", "translate(0," + height + ")")
									  .call(make_x_gridlines()
										  .tickSize(-height)
										  .tickFormat("")
									  )

								// add the Y gridlines
								g3.append("g")			
									  .attr("class", "grid")
									  .call(make_y_gridlines()
										  .tickSize(-width)
										  .tickFormat("")
									  )

								g3.append("g")
									  .append("text") 
									  .attr("transform", "translate(" + (width / 2) + " ," +	(height + margin.top + 20) + ")")
									  .style("text-anchor", "middle")
									  .text("Year"); 

								g3.append("g")
									  .attr("class", "axis axis--x")
									  .attr("transform", "translate(0," + height + ")")
									  .call(d3.axisBottom(x).tickFormat(d3.format('.4'))); 
								
								var y_text;
								if(section == "Groceries_Index") {
									y_text = "Groceries Index"; 
								}
								else if(section == "Rent_Index") {
									y_text = "Rent Index";  
								}
								else if(section == "Restaurant_Price_Index") {
									y_text = "Restaurant Price Index";  
								}
								else if(section == "Local_Purchasing_Power_Index") {
									y_text = "Local Purchasing Power Index";  
								}
								else if(section == "Cost_of_Living_Plus_Rent_Index") {
									y_text = "Cost of Living Plus Rent Index";  
								}
								
								g3.append("g")
									  .attr("class", "axis axis--y")
									  .call(d3.axisLeft(y))
									  .append("text")
									  .attr("transform", "rotate(-90)")
									  .attr("y", -45)
									  .attr("dy", "0.71em")
									  .attr("fill", "#000")
									  .text(y_text);

								var city3 = g3.selectAll(".city")
									.data(cities3)
									.enter().append("g")
									.attr("class", "city");

								city3.append("path")
									  .attr("class", "line")
									  .attr("d", function(d) { return line3(d.values); })
									  .style("stroke", function(d) { return z(d.key); });

								city3.append("text")
									  .datum(function(d) { return {City: d.key, value: d.values[d.values.length - 1]}; })
									  .attr("transform", function(d) { 
									  if(section == "Groceries_Index") {
											return "translate(" + x(d.value.Year) + "," + y(d.value.Groceries_Index) + ")";  
										}
										else if(section == "Rent_Index") {
											return "translate(" + x(d.value.Year) + "," + y(d.value.Rent_Index) + ")";   
										}
										else if(section == "Restaurant_Price_Index") {
											return "translate(" + x(d.value.Year) + "," + y(d.value.Restaurant_Price_Index) + ")";   
										}
										else if(section == "Local_Purchasing_Power_Index") {
											return "translate(" + x(d.value.Year) + "," + y(d.value.Local_Purchasing_Power_Index) + ")";  
										}
										else if(section == "Cost_of_Living_Plus_Rent_Index") {
											return "translate(" + x(d.value.Year) + "," + y(d.value.Cost_of_Living_Plus_Rent_Index) + ")";  
										}
									  
									  })
									  .attr("x", 3)
									  .attr("dy", "0.35em")
									  .style("font", "10px sans-serif")
									  .text(function(d) { return d.City; });
							
								});
							
							});	
		
							function type(d, _, columns) {
							  d.Year = +d.Year;
							  d.Cost_of_Living_Index = +d.Cost_of_Living_Index;
							  d.Cost_of_Living_Plus_Rent_Index = +d.Cost_of_Living_Plus_Rent_Index;
							  d.Groceries_Index = +d.Groceries_Index;
							  d.Local_Purchasing_Power_Index = +d.Local_Purchasing_Power_Index;
							  d.Rent_Index = +d.Rent_Index;
							  d.Restaurant_Price_Index = +d.Restaurant_Price_Index;
							  d.Unemployment_Rate = +d.Unemployment_Rate;
		  
							  return d;
							}
							
						</script>

					</div>
			</div>	
		</div>
		<div class="section" id="section-4">
			<div class="about" style="margin-left: 450px; margin-right: 450px;">
				<p><font size = "8" color="black">About this Visualization</font></p>
			</div>
		</div>
	</div>
	<script type="text/javascript">
	
		var fullPage = new fullpage('#fullpage', {
			//options here
			anchors:['homePage', 'secondPage', 'thirdPage', 'glossaryPage'],
			sectionsColor : ['#ccc', '#fff', '#ccc', '#fff'],
			autoScrolling:true,
			scrollHorizontally: true,
			navigationTooltips: ['homePage', 'secondPage', 'thirdPage', 'glossaryPage'],
			scrollingSpeed: 1000,
            navigation: true,
            slidesNavigation: true,
            licenseKey: "OPEN-SOURCE-GPLV3-LICENSE"
		});
		
		
		
	</script>
</body>

</html>